name: Deploy to Kubernetes

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Select the branch to deploy'
        required: true
        default: 'main'
      pytest_tag:
        description: 'The pytest tag to run tests with'
        required: false
        default: 'home'
      release_tag:
        description: 'Specify the release tag for the Docker image'
        required: false
        default: 'latest'

jobs:
#  Install-Dependencies:
#    runs-on: ubuntu-latest
#    container:
#      image: ubuntu:20.04
#    steps:
#      - name: Cache Python dependencies
#        uses: actions/cache@v3
#        with:
#          path: |
#            .venv/
#            .tox/
#            .nox/
#            .docker/cache/
#            .pip/
#            ~/.cache/pip/
#          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt') }}
#          restore-keys: |
#            ${{ runner.os }}-python-
#
#      - name: Install dependencies
#        run: |
#          set -e
#          apt-get update
#          apt-get install -y python3-pip curl docker.io
#          pip install pytest requests pylint
#
#  Test:
#    needs: [Install-Dependencies]
#    runs-on: ubuntu-latest
#    steps:
#      - name: Install Docker Compose
#        run: |
#          set -e
#          curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
#          chmod +x /usr/local/bin/docker-compose
#
#      - name: Checkout repository
#        uses: actions/checkout@v4
#        with:
#          ref: ${{ inputs.branch }}
#
#      - name: Run Docker Compose and Prepare Report
#        run: |
#          set -e
#          # Create docker volume
#          docker volume create app_volume
#          pip install pytest-html
#
#          if [ -n "${{ inputs.pytest_tag }}" ]; then
#            TEST_TAG="${{ inputs.pytest_tag }}" docker-compose -f docker-compose.test.yml up --build test-app
#          else
#            docker-compose -f docker-compose.test.yml up --build test-app
#          fi
#
#          # Copy files from flask-test to localhost
#          docker cp flask-tests-container:/app/report.xml ./report.xml
#          docker cp flask-tests-container:/app/report.html ./report.html
#          docker cp flask-tests-container:/app/Dockerfile.app ./Dockerfile.app
#          docker cp flask-tests-container:/app/Dockerfile.test ./Dockerfile.test
#
#      - name: Upload XML Report Artifact
#        uses: actions/upload-artifact@v3
#        with:
#          name: xml-report
#          path: ./report.xml
#          retention-days: 1
#
#      - name: Upload HTML Report Artifact
#        uses: actions/upload-artifact@v3
#        with:
#          name: html-report
#          path: ./report.html
#          retention-days: 1
#
#      - name: Install Trivy
#        run: |
#          set -e
#          sudo apt-get update
#          sudo apt-get install -y wget
#          sudo wget https://github.com/aquasecurity/trivy/releases/download/v0.29.1/trivy_0.29.1_Linux-64bit.deb
#          sudo dpkg -i trivy_0.29.1_Linux-64bit.deb
#      - name: Trivy Scan Dockerfile.app
#        run: |
#          set -e
#          sudo trivy config --severity HIGH,CRITICAL ./Dockerfile.app
#      - name: Trivy Scan Dockerfile.test
#        run: |
#          set -e
#          sudo trivy config --severity HIGH,CRITICAL ./Dockerfile.test
#
#  Build-docker-image:
#    needs: [Test]
#    runs-on: ubuntu-latest
#    steps:
#      - name: Checkout repository
#        uses: actions/checkout@v4
#        with:
#          ref: ${{ inputs.branch }}
#      - name: Build Docker image
#        run: |
#          set -e
#          pwd
#          ls -la /home/runner/work/flask-memcached/flask-memcached/src
#          cd src
#          docker build -t ${{ secrets.DOCKER_USERNAME }}/python-memcached:${{ inputs.release_tag }} -f ./Dockerfile.app .
#      - name: Push Docker image to Docker Hub
#        run: |
#          set -e
#          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
#          docker push ${{ secrets.DOCKER_USERNAME }}/python-memcached:${{ inputs.release_tag }}
  Deploy-to-test-env:
    #needs: [Build-docker-image]
    runs-on: ubuntu-latest
    env:
      REMOTE_USER: "kube_user"   # SSH user
    steps:
      # Set up Python and install Ansible
      - name: Set up Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.8'
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Test ssh connectivity
        shell: bash
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_PASSPHRASE: ${{ secrets.SSH_PASSPHRASE }}
        run: |
          set -e  # Exit on any error
      
          # Create the .ssh directory
          mkdir -p ~/.ssh
      
          # Ensure SSH_PRIVATE_KEY is set
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "Error: SSH_PRIVATE_KEY is not set."
            exit 1
          fi
      
          # Create the SSH key file and set permissions
          echo -e "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_gcp_key
          chmod 600 ~/.ssh/id_gcp_key
      
          # Start the SSH agent
          eval $(ssh-agent -s)
      
          # Ensure SSH_PASSPHRASE is set
          if [ -z "$SSH_PASSPHRASE" ]; then
            echo "Error: SSH_PASSPHRASE is not set."
            exit 1
          fi
      
          # Add the private key to the SSH agent
          echo "$SSH_PASSPHRASE" | ssh-add ~/.ssh/id_gcp_key
      
          # Connect to the remote server
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_gcp_key kube_user@34.89.49.245



#      - name: Setup SSH
#        uses: webfactory/ssh-agent@v0.4.1
#        with:
#          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
#
#      # Create SSH private key file
#      - name: Create SSH private key file
#        run: |
#          set -e
#          mkdir -p .ssh
#          echo "${{ secrets.SSH_PRIVATE_KEY }}" > .ssh/id_gcp_key
#          chmod 600 .ssh/id_gcp_key
#
#      # Set up SSH private key from GitHub Secrets and passphrase handling
#      - name: Set up SSH key for GCP
#        run: |
#          set -e
#          eval $(ssh-agent -s)
#          echo "${{ secrets.SSH_PASSPHRASE }}" | ssh-add .ssh/id_gcp_key
#
#      # Optional: Check SSH connection (e.g., just log in to the GCP instance)
#      - name: Test SSH connection to GCP instance
#        run: |
#          set -e
#          ls -la
#          cat .ssh/id_gcp_key
#          # Test the SSH connection to the GCP instance
#          ssh -o StrictHostKeyChecking=no -i .ssh/id_gcp_key kube_user@34.89.49.245

#
#
#
#      # Ping Ansible Host to Verify Connectivity
#      - name: Ping Ansible Host
#        run: |
#          ansible -m ping ${{vars.UBUNTU_GCP}}
#
#      # Run Ansible Playbook directly (without using a hosts file)
#      - name: Run Ansible Playbook on GCP
#        run: |
#          # Run Ansible Playbook directly with SSH key and no hosts file
#          ansible-playbook -i "34.89.49.245," -u kube_user --private-key ~/.ssh/id_gcp_key --ssh-common-args='-o StrictHostKeyChecking=no' playbook.yml

